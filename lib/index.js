// Generated by CoffeeScript 1.10.0
var Config, FrameError, K, None, R, Right, Some, Stomp, StompError, Transport, clientFromConfig, foreach, handleError, pubSub, pubSubs, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

R = require('ramda');

K = require('kefir');

ref = require('fantasy-options'), Some = ref.Some, None = ref.None;

Right = require('fantasy-eithers').Right;

foreach = require('fantasy-contrib-either').foreach;

Stomp = require('stompjs/lib/stomp').Stomp;

ref1 = require('./config'), Transport = ref1.Transport, Config = ref1.Config;

StompError = (function(superClass) {
  extend(StompError, superClass);

  function StompError(message, cause1) {
    this.message = message;
    this.cause = cause1;
    this.name = 'StompError';
  }

  return StompError;

})(Error);

FrameError = (function(superClass) {
  extend(FrameError, superClass);

  function FrameError(frame) {
    this.frame = frame;
    FrameError.__super__.constructor.call(this, this.frame.toString(), None);
    this.name = 'FrameError';
  }

  return FrameError;

})(StompError);

clientFromConfig = function(config) {
  var client, heartbeat, mkError;
  heartbeat = {
    incoming: config.hbRecvFreqMillis,
    outgoing: config.hbSendFreqMillis
  };
  mkError = function(wsErr) {
    return new StompError("Error creating socket: " + wsErr.message, Some(wsErr));
  };
  client = config.transport.cata({
    Tcp: function(h, p) {
      return Right(Stomp.overTCP(h, p));
    },
    Ws: function(ws) {
      return ws().bimap(mkError, Stomp.over);
    }
  });
  foreach(function(c) {
    c.debug = false;
    return c.heartbeat = heartbeat;
  })(client);
  return client;
};

handleError = function(emitter) {
  return function(frameOrString) {
    if (frameOrString instanceof Stomp.Frame) {
      return emitter.error(new FrameError(frameOrString));
    } else {
      return emitter.end();
    }
  };
};

pubSub = R.curry(function(connected, client) {
  var mkError, publish, subscribe;
  mkError = function(action, headers, destination, cause) {
    return new StompError(action + " failed: " + cause.message + ", destination=" + destination + ", headers=" + (JSON.stringify(headers)), Some(cause));
  };
  subscribe = R.curry(function(headers, destination) {
    var frames;
    frames = K.fromBinder(function(emitter) {
      var err, error, sub;
      try {
        sub = client.subscribe(destination, emitter.emit, R.merge({}, headers));
        return sub.unsubscribe;
      } catch (error) {
        err = error;
        emitter.error(mkError("Subscribe", headers, destination, err));
        emitter.end();
        return R.always(void 0);
      }
    });
    return frames.takeWhileBy(connected);
  });
  publish = R.curry(function(headers, destination) {
    var sink;
    sink = K.fromBinder(function(emitter) {
      var pub;
      pub = function(body) {
        return function() {
          var err, error;
          try {
            return client.send(destination, R.merge({}, headers), body);
          } catch (error) {
            err = error;
            emitter.error(mkError("Publish", headers, destination, err));
            return emitter.end();
          }
        };
      };
      emitter.emit(pub);
      return void 0;
    });
    return connected.flatMapLatest(function(isConnected) {
      if (isConnected) {
        return sink.toProperty();
      } else {
        return K.never();
      }
    }).toProperty();
  });
  return {
    publish: publish,
    subscribe: subscribe
  };
});

pubSubs = function(config) {
  var clients, connected, headers;
  headers = config.credentials.fold(R.merge, function() {
    return R.identity;
  })({
    host: config.vhost
  });
  clients = K.fromBinder(function(emitter) {
    return clientFromConfig(config).fold((function(err) {
      emitter.error(err);
      emitter.end();
      return R.always(void 0);
    }), (function(client) {
      client.connect(R.merge({}, headers), (function() {
        return emitter.emit(client);
      }), handleError(emitter));
      return client.disconnect.bind(client);
    }));
  });
  connected = clients.map(R.always(true)).mapEnd(R.always(false)).toProperty(true);
  return clients.map(pubSub(connected)).toProperty();
};

module.exports = {
  pubSubs: pubSubs,
  Transport: Transport,
  Config: Config,
  StompError: StompError,
  FrameError: FrameError
};
